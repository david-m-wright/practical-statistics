---
title: "Joining and reshaping data"
author: "David M Wright - d.wright@qub.ac.uk"
format: html
date: last-modified
date-format: iso
toc: true
self-contained: true
editor: visual
---

## Setup

We will be using two datasets.

The first is a published set of Covid-19 case counts for the UK, the second is a set of Covid-19 case counts released by the World Health Organisation.

Before moving on, download the following files from Canvas and put them in your `data` folder:

1.  `data_2023-Jan-12.csv`

2.  `WHO-COVID-19-global-daily-data.csv`

Then load the required packages and datasets.

```{r load-data}
library(tidyverse)
library(here)

# Load the UK Covid dataset
covid <- read_csv(here("data/data_2023-Jan-12.csv")) %>% 
  mutate(year = year(date),
         month = month(date),
         day = day(date),
         # Label months as a factor with levels in the correct order
         month_lab = factor(month.abb[month], levels = month.abb)
         )

# Load the WHO Covid dataset
who_covid <- read_csv(here("data/WHO-COVID-19-global-daily-data.csv"))

```

## Reshaping

Within a single study, it is common for several different formats of the same data to be required at different stages:

-   During data collection, human readability is important and so often a *wide* format is chosen where each subject has a single row.\
-   When storing data, a *tidy* format is preferred where different types of data are separated into different tables.\
-   When plotting or doing statistical analysis a *long* format is a good choice where there are multiple rows for each subject.

Switching between these formats is an important skill. For this example we will use the Covid dataset. In the Data Wrangling class we totalled the number of new cases by year and month. If we decide that each `year` is a subject then this dataset is in *long* format with multiple rows per year.

```{r pivot1}
# Load the data and separate out the date components
covid <- read_csv(here("data/data_2023-Jan-12.csv")) %>% 
  mutate(year = year(date),
         month = month(date),
         day = day(date),
         # Label months as a factor with levels in the correct order
         month_lab = factor(month.abb[month], levels = month.abb)
         )

# Calculate number of cases per month
cases_month <- covid %>% 
  group_by(year, month_lab) %>% 
  summarise(total_cases = sum(newCasesBySpecimenDate), .groups = "drop")

cases_month

```

We can convert it to *wide* format, with a single row for each year, using `pivot_wider()` from the `tidyverse` package.

```{r pivot2}
cases_wide <- cases_month %>% 
  pivot_wider(names_from = "month_lab", values_from = "total_cases")
cases_wide
```

Missing values can be filled in using the `values_fill` argument.

```{r pivot3}
cases_month %>% 
  pivot_wider(names_from = "month_lab", values_from = "total_cases", values_fill = 0)
```

Sometimes it can be helpful to add a prefix to each wide column name, especially if the new columns names will be numeric otherwise. For example, timepoints 0, 1, ..., 20) in an epidemiological study might be represented with columns named `t_0`, `t_1`, ..., `t_20` rather than `0`, `1`, ..., `20`. The all numeric form can be used for plotting and modelling but we have to remember to quote the column names using backticks ().

```{r pivot3-prefix}
cases_month %>% 
  pivot_wider(names_from = "month_lab", values_from = "total_cases", names_prefix = "m_")
```

We can pivot back to *long* format using `pivot_longer()`. The extra month\*year combinations that were generated by pivoting wider can be dropped using the `values_drop_na` argument.

```{r pivot4}
cases_wide %>% 
  pivot_longer(cols = Jan:Dec, names_to = "month", values_to = "total_cases", values_drop_na = TRUE)
```

### Exercise

1.  Create a new data frame called `cases_reshaped` from the `cases_month` data frame, with each month forming a row and each year forming a column.

2.  Then produce a scatter plot of cases counts for 2020 vs 2021, labelling the points with the name of the month (hint: look up the ggplot geom help pages).

::: {.callout-caution collapse="true"}
### Solution

```{r pivot5}
cases_reshaped <- cases_month %>% 
  pivot_wider(names_from = "year", values_from = "total_cases")
cases_reshaped
```

```{r pivot6}
cases_reshaped %>% 
  ggplot(aes(x = `2020`, y = `2021`)) +
  geom_label(aes(label = month_lab)) +
  scale_y_continuous(labels = ~formatC(., format = "fg", big.mark = ",")) +
  scale_x_continuous(labels = ~formatC(., format = "fg", big.mark = ",")) +
  theme_light()
```
:::

## Joining

We will prepare an extract from the WHO Covid dataset containing just the cumulative case counts from Ireland and France. First select just the columns to be pivoted and then pivot so that there is a column of counts for each country, with the `Date_reported` column as the key. This dataset is arranged in ascending date order (UK counts are in descending order).

```{r join-setup}
ireland_france <- who_covid %>%
  # Select just the columns to be pivoted wider
  select(Date_reported, Country, Cumulative_cases) %>% 
  # Pivot so that each country has a coolum
  pivot_wider(names_from = Country, 
              values_from = Cumulative_cases) %>% 
  # Select only the France and Ireland columns
  select(Date_reported, France, Ireland)

ireland_france
```

A join where only rows present in both data frames are retained is called an *inner join*.

```{r join1}
ireland_france_uk <- ireland_france %>% 
  inner_join(covid, join_by(Date_reported == date)) 

ireland_france_uk
```

To retain all the rows in the *left* table regardless of whether they were matched on the *right*, use a *left join*.

```{r join2}
ireland_france_uk_left <- ireland_france %>% 
  left_join(covid, join_by(Date_reported == date))

ireland_france_uk_left
```

When joining datasets it is good practice to calculate the expected number of rows in the output *before* making the join. If you don't get the number you expect, find out why. There may be multiple matches or data entry errors so that some expected matches did not occur. Use `distinct()` and `nrow()` to check. For example, if there are no duplicates and you expect all matches to be 1:1, the expected number of rows in left joined table should be \<= `nrow(left)`.

```{r join3}
nrow(ireland_france)
nrow(covid)

# Inner join
nrow(ireland_france_uk)
# Left join
nrow(ireland_france_uk_left)

```

To illustrate a join with multiple matches, left join the entire `who_covid` dataset to the `covid` dataset.

```{r join4}
who_joined <- who_covid %>% 
  inner_join(covid, join_by(Date_reported == date)) 
who_joined

```

We can count the number of rows for each `Date_reported` to show how many matches were made for each date.

```{r join5}
who_joined %>% 
  count(Date_reported)
```

Sometimes the join functions gives a warning that a "many-to-many" relationship is present. This may not be what you want! It may be caused by duplicates in both the left- and right-hand datasets. Before joining datasets it is often worth removing duplicates otherwise the number of rows in the joined dataset can inflate dramatically. Careful use of `select()` and `distinct()` can do this. In this example it might be useful to get a data frame of the unique countries listed in the WHO dataset.

```{r join6}
distinct(who_covid, Country)
```

Joined datasets may contain lots of extra columns that are no longer needed. Here the joined three country dataset is presented by using `rename()` to make a column for the UK cumulative case counts and then selecting just the date and the three sets of case counts.

```{r join7}
ireland_france_uk %>%
  rename(UK = cumCasesBySpecimenDate) %>%
  select(Date_reported, France, Ireland, UK)
```

### Exercise

1.  List the dates when new cases were reported in both Samoa and Anguilla.

2.  Count the number of days when a new case was recorded in Samoa but not in Anguilla, classified by the year and month in which they were recorded and arranged from latest to earliest.

::: {.callout-caution collapse="true"}
### Solution

```{r join-exercise}
# 1.
# Make a data frame for each of the two countries
samoa <- who_covid %>% 
  filter(Country == "Samoa" & New_cases > 0)

anguilla <- who_covid %>% 
  filter(Country == "Anguilla" & New_cases > 0)

# Join the two countries
samoa %>% 
  inner_join(anguilla, join_by(Date_reported == Date_reported)) %>% 
  select(Date_reported)

# 2.
# Using left_join()
samoa %>% 
  left_join(anguilla, join_by(Date_reported == Date_reported)) %>%
  filter(is.na(New_cases.y)) %>% 
  mutate(month = month(Date_reported),
         year = year(Date_reported)) %>% 
  count(year, month, name = "days_with_cases") %>% 
  arrange(desc(year), desc(month))

# Alternative method using anti_join()
samoa %>% 
  anti_join(anguilla, join_by(Date_reported == Date_reported)) %>% 
  mutate(month = month(Date_reported),
         year = year(Date_reported)) %>% 
  count(year, month, name = "days_with_cases") %>% 
  arrange(desc(year), desc(month))
  
```
:::
